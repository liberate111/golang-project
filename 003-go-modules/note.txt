### Go modules

## Go modules - intro

# Overview
An overview of go modules.
    GOPATH will always still work for backwards compatibility
    Modules is the new recommended way of doing things however

# Package management
Understanding package management and dependencies. Different names, mostly the same meaning:
    packages
    libraries
    groupings of other people’s code (OPC)
    groupings of your own code
“A module is a collection of related Go packages. Modules are the unit of source code interchange and versioning. The go command has direct support for working with modules, including recording and resolving dependencies on other modules. Modules replace the old GOPATH-based approach to specifying which source files are used in a given build.”
source - at the terminal: go help modules

# Reading Documentation
A module is a collection of Go packages stored in a file tree with a go.mod file at its root.

# Creating a new module
Create a new, empty directory somewhere outside $GOPATH/src.
    $ go mod init <name spacing, eg, example.com/hello>

    $ go test
The go.mod file only appears in the root of the module. Packages in subdirectories have import paths consisting of the module path plus the path to the subdirectory.
    $ cat go.mod

# Adding a dependency
NOTES:
if you import a package/library (call it what you will) not yet tracked by go.mod, by default: 
    go adds it to go.mod, using the latest version.
    “Latest” is defined as 
        latest tagged stable (non-prerelease) version, or
        latest tagged prerelease version, or
        latest untagged version.
    see the version of rsc.io/quote
        cat go.mod
        only direct dependencies are recorded in the go.mod file
    two types of dependencies
        DIRECT dependency
        INDIRECT dependency
    see all direct and indirect dependencies
        $ go list -m all

# Security assurance with go.sum
In addition to go.mod, the go command maintains a file named go.sum containing the expected cryptographic hashes of the content of specific module versions:
ensures the modules your project depends on do not change unexpectedly
Both go.mod and go.sum should be checked into version control.'


## Go modules - deeper dive

# Understanding versioning
With Go modules, versions are referenced with semantic version tags. A semantic version has three parts: 
    major.minor.patch
For example, for v0.1.2, 
    major version is 0
    minor version is 1
    patch version is 2
Here is a description of each part:
    MAJOR
        backwards incompatible changes added
    MINOR
        backwards compatible changes added
    PATCH 
        backwards compatible bug fixes

# Upgrading a minor dependency
Let's walk through a couple minor version upgrades. Then, we’ll consider a major version upgrade. From the output of ...
    $ go list -m all
... we can see we're using an untagged version of golang.org/x/text. The golang.org/x/text version is something like this ...
v0.0.0-20170915032832-14c0d48ead0c 
… and is an example of a pseudo-version, which is the go command's version syntax for a specific untagged commit. Let's upgrade to the latest tagged version - either of these commands work (and we will see how we can do @v1.3.1 in the next video):
    $ go get golang.org/x/text
    $ go get golang.org/x/text@latest
Each argument passed to go get can take an explicit version. The default is @latest which resolves to the latest version as defined earlier. Now let’s test that everything still works:
    $ go test
What do our dependencies look like now?
    $ go list -m all
The golang.org/x/text package has been upgraded to the latest tagged version. What does our go.mod file look like now?
    $ cat go.mod
The indirect comment indicates a dependency is not used directly by this module, only indirectly by other module dependencies. See go help modules for details.

# Specifying dependency version
See all of your direct and indirect dependencies
    $ go list -m all
Now let's try upgrading the rsc.io/sampler minor version. 
    $ go get rsc.io/sampler@latest
    $ go test
Uh, oh! The test failure shows that the latest version of rsc.io/sampler is incompatible with our usage. Let's list the available tagged versions of that module.
    $ go list -m -versions rsc.io/sampler
rsc.io/sampler v1.99.99 should have been backwards-compatible with rsc.io/sampler v1.3.0, but bugs or incorrect client assumptions about module behavior can both happen. Let’s get a different version
    $ go get rsc.io/sampler@v1.3.1
Each argument passed to go get can take an explicit version
the default is @latest which resolves to the latest version as defined earlier.
or you can specify the version like the above @v1.3.1

# Adding a new major dependency
Let's add a new function to our package:
you can have different versions of the same package / library / code (call it what you will)
Each different major version (v1, v2, and so on) uses a different module path
    starting at v2, the path must end in the major version
    this gives incompatible packages (different major versions) different names
    you can only use one of each major version - example: 
        rsc.io/quote
        rsc.io/quote/v2
        rsc.io/quote/v3, and so on. 
    it is impossible for a program to build with both rsc.io/quote v1.5.2 and rsc.io/quote v1.6.0
    allowing different major versions of a module (because they have different paths) gives module consumers the ability to upgrade to a new major version incrementally. 
        The ability to migrate incrementally is especially important in a large program or codebase.

# Upgrading a major dependency
Let's complete our conversion from rsc.io/quote to only rsc.io/quote/v3. If we look at the documentation of the package using go doc:
    $ go doc rsc.io/quote/v3
Because of the major version change, we should expect that some APIs may have been removed, renamed, or otherwise changed in incompatible ways

# Removing unused dependencies
We've removed all our uses of rsc.io/quote, but it still shows up in go list -m all and in our go.mod file:
    $ cat go.mod
    $ go list -m all
Building a single package, like with go build or go test, can easily tell when something is missing and needs to be added, but not when something can safely be removed. Removing a dependency can only be done after checking all packages in a module, and all possible build tag combinations for those packages. An ordinary build command does not load this information, and so it cannot safely remove dependencies. The go mod tidy command cleans up these unused dependencies:
    $ go mod tidy
    $ cat go.mod
    $ go list -m all


## Go modules - good to know

# Automatic conversion
If you are already using dependency manager like dep or glide or something else, the command go mod init will automatically convert your dependency management to go modules. These are the older dependency management tools that automatically convert to go modules. To convert, 
    navigate to the root of your project
    go mod init
    go mod tidy
Note that other dependency managers may specify dependencies at the level of individual packages or entire repositories (not modules), and generally do not recognize the requirements specified in the go.mod files of dependencies. Consequently, you may not get exactly the same version of every package as before, and there's some risk of upgrading past breaking changes. Therefore, it's important to follow the above commands with an audit of the resulting dependencies. To do so, run
    go list -m all
Upgrade or downgrade to the correct version using go get as needed.

# The module mirror & privacy
A module mirror is a special kind of module proxy that caches metadata and source code in its own storage system, allowing the mirror to continue to serve source code that is no longer available from the original locations. This can speed up downloads and protect you from disappearing dependencies.
The Go team maintains a module mirror, served at proxy.golang.org, which the go command will use by default for module users as of Go 1.13. If you are running an earlier version of the go command, then you can use this service by setting GOPROXY=https://proxy.golang.org in your local environment.
GOPRIVATE
source: https://blog.golang.org/module-mirror-launch& 
video: https://www.youtube.com/watch?v=KqTySYYhPUE

# Modules and git commit versioning
A “git tag” allows you to tag a particular commit with some name. With golang modules, you tag should follow semantic versioning. Here are the commands to use:
create a tag         
    $ git tag <tag name>
show a list of all the tags
    $ git tag
push a tag
    $ git push --tags
    $ git push origin <tag name>

# Releasing major versions in go modules
at go.mod
    module gomodules >> module gomodules/v2

# Git forks and module path replacement
You can alias one package name with another package name
    fork repo
    fix bug
    pull request then wait to merge
    > don't wait 
    $ go help mod
    $ go help mod edit
    $ go mod edit -replace=<github.com/GoesToEleven/golang-project=github.com/liberate111/golang-project
    $ go mod edit -replace=<github.com/GoesToEleven/golang-project=github.com/liberate111/golang-project@master

# Review commands
$ go mod init <add your name space>
creates a new module, initializing the go.mod file that describes it. 

$ go build, go test 
and other package-building commands add new dependencies to go.mod as needed. 

$ cat go.mod 
shows the contents of go.mod file

$ go list -m all 
prints the current module’s dependencies. 
    direct
    indirect

$ go list -m -versions <package name>
    lists all of the versions of a package

$ go get <package name>
    changes the required version of a dependency (or adds a new dependency).
    example: go get rsc.io/sampler@v1.3.1
    defaults to @latest

$ go mod tidy 
    removes unused dependencies.
    adds dependencies for other platforms

$ go doc <package name>
    shows us the documentation of a package.
    example: go doc fmt

tags
create a tag         
    $ git tag <tag name>
show a list of all the tags
    $ git tag
push a tag
    $ git push --tags
    $ git push origin <tag name>
